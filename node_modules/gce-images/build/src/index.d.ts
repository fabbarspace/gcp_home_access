import { GoogleAuth, GoogleAuthOptions } from 'google-auth-library';
export interface GCEImagesConfig extends GoogleAuthOptions {
    authClient?: GoogleAuth;
    /**
     * The host name used to access the compute API.
     * Defaults to `compute.googleapis.com`.
     */
    apiEndpoint?: string;
}
export interface GetOptions {
    deprecated?: boolean;
    osNames?: string[];
}
export interface Image {
    creationTimestamp: string;
    deprecated: boolean;
    kind: 'compute#image';
    selfLink: string;
    id: string;
    name: string;
    description: string;
    sourceType: string;
    rawDisk: {
        source: string;
        containerType: string;
    };
    status: string;
    archiveSizeBytes: number;
    diskSizeGb: number;
    licenses: string[];
}
export interface GetAllCallback {
    (err: Error | null, images?: Image[] | ImagesMap): void;
}
export interface GetLatestCallback {
    (err: Error | null, images?: Image | ImageMap): void;
}
export interface ImagesMap {
    [index: string]: Image[];
}
export interface ImageMap {
    [index: string]: Image;
}
interface ParsedArguments<O, C> {
    options: O;
    callback: C;
}
export interface OSUrls {
    centos: string;
    'container-vm': string;
    coreos: string;
    debian: string;
    redhat: string;
    opensuse: string;
    suse: string;
    ubuntu: string;
    windows: string;
}
export declare class GCEImages {
    private _auth;
    private apiEndpoint;
    OS_URLS: OSUrls;
    OS_TO_URL: {
        [index: string]: string;
    };
    constructor(config?: GCEImagesConfig);
    getProjectId(): Promise<string>;
    /**
     * Get all available images.
     *
     * @param {string=|object=} options - If a string, treat as an OS to fetch images for.
     * @param {boolean} options.deprecated [false] - Include deprecated results.
     * @param {array} options.osNames [all] - OS names to include in the results.
     * @param {function} callback - Callback function.
     * @returns {Promise} if callback is omitted.
     */
    getAll(cb: GetAllCallback): void;
    getAll(opts?: GetOptions | string): Promise<Image[] | ImagesMap>;
    getAll(opts: GetOptions | string, cb: GetAllCallback): void;
    private getAllAsync;
    /**
     * Get all available images, but only return the newest one.
     *
     * @param {string=|object=} options - If a string, treat as an OS to fetch
     *                                    images for.
     * @param {boolean} options.deprecated [false] - Include deprecated results.
     * @param {array} options.osNames [all] - OS names to include in the results.
     * @param {function} callback - Callback function.
     * @returns {Promise} if callback is omitted.
     */
    getLatest(cb: GetLatestCallback): void;
    getLatest(opts?: GetOptions | string): Promise<Image | ImageMap>;
    getLatest(opts: GetOptions | string, cb: GetLatestCallback): void;
    private getLatestAsync;
    _getAllByOS(options: GetOptions & {
        osNames: string[];
    }): Promise<Image[]>;
    _parseArguments<O, C>(options: any, callback: any): ParsedArguments<O, C>;
    _parseOsInput(os: string): {
        name: string;
        version: string;
        url: string;
    };
    _filterDeprecated(image: Image): boolean;
    _sortNewestFirst(imageA: Image, imageB: Image): 0 | 1 | -1;
}
export {};
